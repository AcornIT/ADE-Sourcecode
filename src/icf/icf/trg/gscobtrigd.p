/*********************************************************************
* Copyright (C) 2000 by Progress Software Corporation ("PSC"),       *
* 14 Oak Park, Bedford, MA 01730, and other contributors as listed   *
* below.  All Rights Reserved.                                       *
*                                                                    *
* The Initial Developer of the Original Code is PSC.  The Original   *
* Code is Progress IDE code released to open source December 1, 2000.*
*                                                                    *
* The contents of this file are subject to the Possenet Public       *
* License Version 1.0 (the "License"); you may not use this file     *
* except in compliance with the License.  A copy of the License is   *
* available as of the date of this notice at                         *
* http://www.possenet.org/license.html                               *
*                                                                    *
* Software distributed under the License is distributed on an "AS IS"*
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. You*
* should refer to the License for the specific language governing    *
* rights and limitations under the License.                          *
*                                                                    *
* Contributors: MIP Holdings (Pty) Ltd ("MIP")                       *
*               PSC                                                  *
*                                                                    *
*********************************************************************/

TRIGGER PROCEDURE FOR DELETE OF gsc_object .

/* generic trigger override include file to disable trigger if required */
{af/sup2/aftrigover.i &DB-NAME      = "ICFDB"
                      &TABLE-NAME   = "gsc_object"
                      &TRIGGER-TYPE = "DELETE"}

/* Created automatically using ERwin ICF Trigger template db/af/erw/afercustrg.i
   Do not change manually. Customisations to triggers should be placed in separate
   include files pulled into the trigger. ICF auto generates write trigger custom
   include files. Delete or create customisation include files need to be created
   manually. Be sure to put the hook in ERwin directly so as not to have you changes
   overwritten.
   User defined Macro (UDP) Summary (case sensitive)
   gsc_object           Expands to full table name, e.g. gsm_user
   %TableFLA            Expands to table unique code, e.g. gsmus
   %TableObj            If blank or not defined expands to table_obj with no prefix (framework standard)
                        If defined, uses this field as the object field
                        If set to "none" then indicates table does not have an object field
   XYZ                  Do not define so we can compare against an empty string

   See docs for explanation of replication macros 
*/   

&SCOPED-DEFINE TRIGGER_TABLE gsc_object
&SCOPED-DEFINE TRIGGER_FLA gscob
&SCOPED-DEFINE TRIGGER_OBJ object_obj


DEFINE BUFFER lb_table FOR gsc_object.      /* Used for recursive relationships */
DEFINE BUFFER lb1_table FOR gsc_object.     /* Used for lock upgrades */

DEFINE BUFFER o_gsc_object FOR gsc_object.

/* Standard top of DELETE trigger code */
{af/sup/aftrigtopd.i}

  




/* Generated by ICF ERwin Template */
/* gsc_object contains (for SmartToolbar type) gsm_toolbar_menu_structure ON PARENT DELETE CASCADE */
&IF DEFINED(lbe_toolbar_menu_structure) = 0 &THEN
  DEFINE BUFFER lbe_toolbar_menu_structure FOR gsm_toolbar_menu_structure.
  &GLOBAL-DEFINE lbe_toolbar_menu_structure yes
&ENDIF
FOR EACH gsm_toolbar_menu_structure NO-LOCK
   WHERE gsm_toolbar_menu_structure.object_obj = gsc_object.object_obj
   ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete gsm_toolbar_menu_structure":U:
    FIND FIRST lbe_toolbar_menu_structure EXCLUSIVE-LOCK
         WHERE ROWID(lbe_toolbar_menu_structure) = ROWID(gsm_toolbar_menu_structure)
         NO-ERROR.
    IF AVAILABLE lbe_toolbar_menu_structure THEN
      DO:
        {af/sup/afvalidtrg.i &action = "DELETE" &table = "lbe_toolbar_menu_structure"}
      END.
END.





/* Generated by ICF ERwin Template */
/* gsc_object is run by ryc_action ON PARENT DELETE CASCADE */
&IF DEFINED(lbe_action) = 0 &THEN
  DEFINE BUFFER lbe_action FOR ryc_action.
  &GLOBAL-DEFINE lbe_action yes
&ENDIF
FOR EACH ryc_action NO-LOCK
   WHERE ryc_action.object_obj = gsc_object.object_obj
   ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete ryc_action":U:
    FIND FIRST lbe_action EXCLUSIVE-LOCK
         WHERE ROWID(lbe_action) = ROWID(ryc_action)
         NO-ERROR.
    IF AVAILABLE lbe_action THEN
      DO:
        {af/sup/afvalidtrg.i &action = "DELETE" &table = "lbe_action"}
      END.
END.





/* Generated by ICF ERwin Template */
/* gsc_object is run during gsm_flow_step ON PARENT DELETE RESTRICT */
IF CAN-FIND(FIRST gsm_flow_step WHERE
    gsm_flow_step.object_obj = gsc_object.object_obj) THEN
    DO:
      /* Cannot delete parent because child exists! */
      ASSIGN lv-error = YES lv-errgrp = "AF ":U lv-errnum = 101 lv-include = "gsc_object|gsm_flow_step":U.
      RUN error-message (lv-errgrp, lv-errnum, lv-include).
    END.



/* Generated by ICF ERwin Template */
/* gsc_object may be run on gsm_valid_object_partition ON PARENT DELETE CASCADE */
&IF DEFINED(lbe_valid_object_partition) = 0 &THEN
  DEFINE BUFFER lbe_valid_object_partition FOR gsm_valid_object_partition.
  &GLOBAL-DEFINE lbe_valid_object_partition yes
&ENDIF
FOR EACH gsm_valid_object_partition NO-LOCK
   WHERE gsm_valid_object_partition.object_obj = gsc_object.object_obj
   ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete gsm_valid_object_partition":U:
    FIND FIRST lbe_valid_object_partition EXCLUSIVE-LOCK
         WHERE ROWID(lbe_valid_object_partition) = ROWID(gsm_valid_object_partition)
         NO-ERROR.
    IF AVAILABLE lbe_valid_object_partition THEN
      DO:
        {af/sup/afvalidtrg.i &action = "DELETE" &table = "lbe_valid_object_partition"}
      END.
END.





/* Generated by ICF ERwin Template */
/* gsc_object is the management object for gsc_service_type ON PARENT DELETE RESTRICT */
IF CAN-FIND(FIRST gsc_service_type WHERE
    gsc_service_type.management_object_obj = gsc_object.object_obj) THEN
    DO:
      /* Cannot delete parent because child exists! */
      ASSIGN lv-error = YES lv-errgrp = "AF ":U lv-errnum = 101 lv-include = "gsc_object|gsc_service_type":U.
      RUN error-message (lv-errgrp, lv-errnum, lv-include).
    END.



/* Generated by ICF ERwin Template */
/* gsc_object maintains gsc_service_type ON PARENT DELETE RESTRICT */
IF CAN-FIND(FIRST gsc_service_type WHERE
    gsc_service_type.maintenance_object_obj = gsc_object.object_obj) THEN
    DO:
      /* Cannot delete parent because child exists! */
      ASSIGN lv-error = YES lv-errgrp = "AF ":U lv-errnum = 101 lv-include = "gsc_object|gsc_service_type":U.
      RUN error-message (lv-errgrp, lv-errnum, lv-include).
    END.



/* Generated by ICF ERwin Template */
/* gsc_object is the procedure object for gsm_required_manager ON PARENT DELETE RESTRICT */
IF CAN-FIND(FIRST gsm_required_manager WHERE
    gsm_required_manager.object_obj = gsc_object.object_obj) THEN
    DO:
      /* Cannot delete parent because child exists! */
      ASSIGN lv-error = YES lv-errgrp = "AF ":U lv-errnum = 101 lv-include = "gsc_object|gsm_required_manager":U.
      RUN error-message (lv-errgrp, lv-errnum, lv-include).
    END.



/* Generated by ICF ERwin Template */
/* gsc_object uses these dynamic gsm_object_menu_structure ON PARENT DELETE CASCADE */
&IF DEFINED(lbe_object_menu_structure) = 0 &THEN
  DEFINE BUFFER lbe_object_menu_structure FOR gsm_object_menu_structure.
  &GLOBAL-DEFINE lbe_object_menu_structure yes
&ENDIF
FOR EACH gsm_object_menu_structure NO-LOCK
   WHERE gsm_object_menu_structure.object_obj = gsc_object.object_obj
   ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete gsm_object_menu_structure":U:
    FIND FIRST lbe_object_menu_structure EXCLUSIVE-LOCK
         WHERE ROWID(lbe_object_menu_structure) = ROWID(gsm_object_menu_structure)
         NO-ERROR.
    IF AVAILABLE lbe_object_menu_structure THEN
      DO:
        {af/sup/afvalidtrg.i &action = "DELETE" &table = "lbe_object_menu_structure"}
      END.
END.





/* Generated by ICF ERwin Template */
/* gsc_object appears on gsm_menu_item ON PARENT DELETE CASCADE */
&IF DEFINED(lbe_menu_item) = 0 &THEN
  DEFINE BUFFER lbe_menu_item FOR gsm_menu_item.
  &GLOBAL-DEFINE lbe_menu_item yes
&ENDIF
FOR EACH gsm_menu_item NO-LOCK
   WHERE gsm_menu_item.object_obj = gsc_object.object_obj
   ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete gsm_menu_item":U:
    FIND FIRST lbe_menu_item EXCLUSIVE-LOCK
         WHERE ROWID(lbe_menu_item) = ROWID(gsm_menu_item)
         NO-ERROR.
    IF AVAILABLE lbe_menu_item THEN
      DO:
        {af/sup/afvalidtrg.i &action = "DELETE" &table = "lbe_menu_item"}
      END.
END.





/* Generated by ICF ERwin Template */
/* gsc_object uses gsm_security_structure ON PARENT DELETE SET NULL */

&IF DEFINED(lbe_security_structure) = 0 &THEN
  DEFINE BUFFER lbe_security_structure FOR gsm_security_structure.
  &GLOBAL-DEFINE lbe_security_structure yes
&ENDIF
FOR EACH gsm_security_structure NO-LOCK
   WHERE gsm_security_structure.object_obj = gsc_object.object_obj
   ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^update gsm_security_structure":U:
    FIND FIRST lbe_security_structure EXCLUSIVE-LOCK
         WHERE ROWID(lbe_security_structure) = ROWID(gsm_security_structure)
         NO-ERROR.
    IF AVAILABLE lbe_security_structure THEN
      DO:
        
        ASSIGN lbe_security_structure.object_obj = 0 .
      END.
END.





/* Generic comments deletion */
DEFINE BUFFER lbx_gsm_comment FOR gsm_comment.
DEFINE BUFFER lby_gsm_comment FOR gsm_comment.
IF CAN-FIND(FIRST lbx_gsm_comment 
            WHERE lbx_gsm_comment.owning_obj = gsc_object.{&TRIGGER_OBJ}) THEN
    FOR EACH lbx_gsm_comment NO-LOCK
       WHERE lbx_gsm_comment.owning_obj = gsc_object.{&TRIGGER_OBJ}
       ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete gsm_comment":U:
        FIND FIRST lby_gsm_comment EXCLUSIVE-LOCK
             WHERE ROWID(lby_gsm_comment) = ROWID(lbx_gsm_comment)
             NO-ERROR.
        IF AVAILABLE lby_gsm_comment THEN
          DO:
            {af/sup/afvalidtrg.i &action = "DELETE" &table = "lby_gsm_comment"}
          END.
    END.
/* Generic security allocation deletion */
DEFINE BUFFER lbx_gsm_user_allocation FOR gsm_user_allocation.
DEFINE BUFFER lby_gsm_user_allocation FOR gsm_user_allocation.
IF CAN-FIND(FIRST lbx_gsm_user_allocation 
            WHERE lbx_gsm_user_allocation.owning_obj = gsc_object.{&TRIGGER_OBJ}) THEN
    FOR EACH lbx_gsm_user_allocation NO-LOCK
       WHERE lbx_gsm_user_allocation.owning_obj = gsc_object.{&TRIGGER_OBJ}
       ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete gsm_user_allocation":U:
        FIND FIRST lby_gsm_user_allocation EXCLUSIVE-LOCK
             WHERE ROWID(lby_gsm_user_allocation) = ROWID(lbx_gsm_user_allocation)
             NO-ERROR.
        IF AVAILABLE lby_gsm_user_allocation THEN
          DO:
            {af/sup/afvalidtrg.i &action = "DELETE" &table = "lby_gsm_user_allocation"}
          END.
    END.
/* Generic multi-media deletion */
DEFINE BUFFER lbx_gsm_multi_media FOR gsm_multi_media.
DEFINE BUFFER lby_gsm_multi_media FOR gsm_multi_media.
IF CAN-FIND(FIRST lbx_gsm_multi_media 
            WHERE lbx_gsm_multi_media.owning_obj = gsc_object.{&TRIGGER_OBJ}) THEN
    FOR EACH lbx_gsm_multi_media NO-LOCK
       WHERE lbx_gsm_multi_media.owning_obj = gsc_object.{&TRIGGER_OBJ}
       ON STOP UNDO, RETURN ERROR "AF^104^gscobtrigd.p^delete gsm_multi_media":U:
        FIND FIRST lby_gsm_multi_media EXCLUSIVE-LOCK
             WHERE ROWID(lby_gsm_multi_media) = ROWID(lbx_gsm_multi_media)
             NO-ERROR.
        IF AVAILABLE lby_gsm_multi_media THEN
          DO:
            {af/sup/afvalidtrg.i &action = "DELETE" &table = "lby_gsm_multi_media"}
          END.
    END.








/* Update Audit Log */
IF CAN-FIND(FIRST gsc_entity_mnemonic
            WHERE gsc_entity_mnemonic.entity_mnemonic = 'gscob':U
              AND gsc_entity_mnemonic.auditing_enabled = YES) THEN
  RUN af/app/afauditlgp.p (INPUT "DELETE":U, INPUT "gscob":U, INPUT BUFFER gsc_object:HANDLE, INPUT BUFFER o_gsc_object:HANDLE).

/* Standard bottom of DELETE trigger code */
{af/sup/aftrigendd.i}


/* Place any specific DELETE trigger customisations here */
